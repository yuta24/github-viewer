// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Details of a deployment that is waiting for protection rules to pass
public struct PendingDeployment: Codable {
    public var environment: Environment
    /// The set duration of the wait timer
    ///
    /// Example: 30
    public var waitTimer: Int
    /// The time that the wait timer began.
    ///
    /// Example: "2020-11-23T22:00:40Z"
    public var waitTimerStartedAt: Date?
    /// Whether the currently authenticated user can approve the deployment
    ///
    /// Example: true
    public var currentUserCanApprove: Bool
    /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
    public var reviewers: [Reviewer]

    public struct Environment: Codable, Identifiable {
        /// The id of the environment.
        ///
        /// Example: 56780428
        public var id: Int?
        /// Example: "MDExOkVudmlyb25tZW50NTY3ODA0Mjg="
        public var nodeID: String?
        /// The name of the environment.
        ///
        /// Example: "staging"
        public var name: String?
        /// Example: "https://api.github.com/repos/github/hello-world/environments/staging"
        public var url: String?
        /// Example: "https://github.com/github/hello-world/deployments/activity_log?environments_filter=staging"
        public var htmlURL: String?

        public init(id: Int? = nil, nodeID: String? = nil, name: String? = nil, url: String? = nil, htmlURL: String? = nil) {
            self.id = id
            self.nodeID = nodeID
            self.name = name
            self.url = url
            self.htmlURL = htmlURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decodeIfPresent(Int.self, forKey: "id")
            self.nodeID = try values.decodeIfPresent(String.self, forKey: "node_id")
            self.name = try values.decodeIfPresent(String.self, forKey: "name")
            self.url = try values.decodeIfPresent(String.self, forKey: "url")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(id, forKey: "id")
            try values.encodeIfPresent(nodeID, forKey: "node_id")
            try values.encodeIfPresent(name, forKey: "name")
            try values.encodeIfPresent(url, forKey: "url")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
        }
    }

    public struct Reviewer: Codable {
        /// The type of reviewer.
        ///
        /// Example: "User"
        public var type: DeploymentReviewerType?
        public var reviewer: Reviewer?

        public struct Reviewer: Codable {
            public var simpleUser: SimpleUser?
            /// Groups of organization members that gives permissions on specified repositories.
            public var team: Team?

            public init(simpleUser: SimpleUser? = nil, team: Team? = nil) {
                self.simpleUser = simpleUser
                self.team = team
            }

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                self.simpleUser = try? container.decode(SimpleUser.self)
                self.team = try? container.decode(Team.self)
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = simpleUser { try container.encode(value) }
                if let value = team { try container.encode(value) }
            }
        }

        public init(type: DeploymentReviewerType? = nil, reviewer: Reviewer? = nil) {
            self.type = type
            self.reviewer = reviewer
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.type = try values.decodeIfPresent(DeploymentReviewerType.self, forKey: "type")
            self.reviewer = try values.decodeIfPresent(Reviewer.self, forKey: "reviewer")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encodeIfPresent(type, forKey: "type")
            try values.encodeIfPresent(reviewer, forKey: "reviewer")
        }
    }

    public init(environment: Environment, waitTimer: Int, waitTimerStartedAt: Date? = nil, currentUserCanApprove: Bool, reviewers: [Reviewer]) {
        self.environment = environment
        self.waitTimer = waitTimer
        self.waitTimerStartedAt = waitTimerStartedAt
        self.currentUserCanApprove = currentUserCanApprove
        self.reviewers = reviewers
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.environment = try values.decode(Environment.self, forKey: "environment")
        self.waitTimer = try values.decode(Int.self, forKey: "wait_timer")
        self.waitTimerStartedAt = try values.decodeIfPresent(Date.self, forKey: "wait_timer_started_at")
        self.currentUserCanApprove = try values.decode(Bool.self, forKey: "current_user_can_approve")
        self.reviewers = try values.decode([Reviewer].self, forKey: "reviewers")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(environment, forKey: "environment")
        try values.encode(waitTimer, forKey: "wait_timer")
        try values.encodeIfPresent(waitTimerStartedAt, forKey: "wait_timer_started_at")
        try values.encode(currentUserCanApprove, forKey: "current_user_can_approve")
        try values.encode(reviewers, forKey: "reviewers")
    }
}
