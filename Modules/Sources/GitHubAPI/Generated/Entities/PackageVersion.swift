// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// A version of a software package
public struct PackageVersion: Codable, Identifiable {
    /// Unique identifier of the package version.
    public var id: Int
    /// The name of the package version.
    ///
    /// Example: "latest"
    public var name: String
    /// Example: "https://api.github.com/orgs/github/packages/container/super-linter/versions/786068"
    public var url: String
    /// Example: "https://github.com/orgs/github/packages/container/package/super-linter"
    public var packageHTMLURL: String
    /// Example: "https://github.com/orgs/github/packages/container/super-linter/786068"
    public var htmlURL: String?
    /// Example: "MIT"
    public var license: String?
    public var description: String?
    /// Example: "2011-04-10T20:09:31Z"
    public var createdAt: Date
    /// Example: "2014-03-03T18:58:10Z"
    public var updatedAt: Date
    /// Example: "2014-03-03T18:58:10Z"
    public var deletedAt: Date?
    /// Package Version Metadata
    public var metadata: Metadata?

    /// Package Version Metadata
    public struct Metadata: Codable {
        /// Example: "docker"
        public var packageType: PackageType
        /// Container Metadata
        public var container: Container?
        /// Docker Metadata
        public var docker: Docker?

        /// Example: "docker"
        public enum PackageType: String, Codable, CaseIterable {
            case npm
            case maven
            case rubygems
            case docker
            case nuget
            case container
        }

        /// Container Metadata
        public struct Container: Codable {
            public var tags: [String]

            public init(tags: [String]) {
                self.tags = tags
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.tags = try values.decode([String].self, forKey: "tags")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(tags, forKey: "tags")
            }
        }

        /// Docker Metadata
        public struct Docker: Codable {
            public var tag: [String]?
            public var tags: AnyJSON

            public init(tag: [String]? = nil, tags: AnyJSON) {
                self.tag = tag
                self.tags = tags
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.tag = try values.decodeIfPresent([String].self, forKey: "tag")
                self.tags = try values.decode(AnyJSON.self, forKey: "tags")
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(tag, forKey: "tag")
                try values.encode(tags, forKey: "tags")
            }
        }

        public init(packageType: PackageType, container: Container? = nil, docker: Docker? = nil) {
            self.packageType = packageType
            self.container = container
            self.docker = docker
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.packageType = try values.decode(PackageType.self, forKey: "package_type")
            self.container = try values.decodeIfPresent(Container.self, forKey: "container")
            self.docker = try values.decodeIfPresent(Docker.self, forKey: "docker")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(packageType, forKey: "package_type")
            try values.encodeIfPresent(container, forKey: "container")
            try values.encodeIfPresent(docker, forKey: "docker")
        }
    }

    public init(id: Int, name: String, url: String, packageHTMLURL: String, htmlURL: String? = nil, license: String? = nil, description: String? = nil, createdAt: Date, updatedAt: Date, deletedAt: Date? = nil, metadata: Metadata? = nil) {
        self.id = id
        self.name = name
        self.url = url
        self.packageHTMLURL = packageHTMLURL
        self.htmlURL = htmlURL
        self.license = license
        self.description = description
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.deletedAt = deletedAt
        self.metadata = metadata
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.id = try values.decode(Int.self, forKey: "id")
        self.name = try values.decode(String.self, forKey: "name")
        self.url = try values.decode(String.self, forKey: "url")
        self.packageHTMLURL = try values.decode(String.self, forKey: "package_html_url")
        self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        self.license = try values.decodeIfPresent(String.self, forKey: "license")
        self.description = try values.decodeIfPresent(String.self, forKey: "description")
        self.createdAt = try values.decode(Date.self, forKey: "created_at")
        self.updatedAt = try values.decode(Date.self, forKey: "updated_at")
        self.deletedAt = try values.decodeIfPresent(Date.self, forKey: "deleted_at")
        self.metadata = try values.decodeIfPresent(Metadata.self, forKey: "metadata")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(id, forKey: "id")
        try values.encode(name, forKey: "name")
        try values.encode(url, forKey: "url")
        try values.encode(packageHTMLURL, forKey: "package_html_url")
        try values.encodeIfPresent(htmlURL, forKey: "html_url")
        try values.encodeIfPresent(license, forKey: "license")
        try values.encodeIfPresent(description, forKey: "description")
        try values.encode(createdAt, forKey: "created_at")
        try values.encode(updatedAt, forKey: "updated_at")
        try values.encodeIfPresent(deletedAt, forKey: "deleted_at")
        try values.encodeIfPresent(metadata, forKey: "metadata")
    }
}
