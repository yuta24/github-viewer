// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation

/// Create a new snapshot of a repository's dependencies.
public struct Snapshot: Codable {
    /// The version of the repository snapshot submission.
    public var version: Int
    public var job: Job
    /// The commit SHA associated with this dependency snapshot.
    ///
    /// Example: "ddc951f4b1293222421f2c8df679786153acf689"
    public var sha: String
    /// The repository branch that triggered this snapshot.
    ///
    /// Example: "refs/heads/main"
    public var ref: String
    /// A description of the detector used.
    public var detector: Detector
    /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
    public var metadata: [String: Metadatum]?
    /// A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.
    public var manifests: [String: Manifest]?
    /// The time at which the snapshot was scanned.
    ///
    /// Example: "2020-06-13T14:52:50-05:00"
    public var scanned: Date

    public struct Job: Codable, Identifiable {
        /// The external ID of the job.
        ///
        /// Example: "5622a2b0-63f6-4732-8c34-a1ab27e102a11"
        public var id: String
        /// Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository's current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you're using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you're using a build matrix, then you'll also need to add additional key(s) to distinguish between each submission inside a matrix variation.
        ///
        /// Example: "yourworkflowname_yourjobname"
        public var correlator: String
        /// The url for the job.
        ///
        /// Example: "http://example.com/build"
        public var htmlURL: String?

        public init(id: String, correlator: String, htmlURL: String? = nil) {
            self.id = id
            self.correlator = correlator
            self.htmlURL = htmlURL
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.id = try values.decode(String.self, forKey: "id")
            self.correlator = try values.decode(String.self, forKey: "correlator")
            self.htmlURL = try values.decodeIfPresent(String.self, forKey: "html_url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(id, forKey: "id")
            try values.encode(correlator, forKey: "correlator")
            try values.encodeIfPresent(htmlURL, forKey: "html_url")
        }
    }

    /// A description of the detector used.
    public struct Detector: Codable {
        /// The name of the detector used.
        ///
        /// Example: "docker buildtime detector"
        public var name: String
        /// The version of the detector used.
        ///
        /// Example: "1.0.0"
        public var version: String
        /// The url of the detector used.
        ///
        /// Example: "http://example.com/docker-buildtimer-detector"
        public var url: String

        public init(name: String, version: String, url: String) {
            self.name = name
            self.version = version
            self.url = url
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: StringCodingKey.self)
            self.name = try values.decode(String.self, forKey: "name")
            self.version = try values.decode(String.self, forKey: "version")
            self.url = try values.decode(String.self, forKey: "url")
        }

        public func encode(to encoder: Encoder) throws {
            var values = encoder.container(keyedBy: StringCodingKey.self)
            try values.encode(name, forKey: "name")
            try values.encode(version, forKey: "version")
            try values.encode(url, forKey: "url")
        }
    }

    public init(version: Int, job: Job, sha: String, ref: String, detector: Detector, metadata: [String: Metadatum]? = nil, manifests: [String: Manifest]? = nil, scanned: Date) {
        self.version = version
        self.job = job
        self.sha = sha
        self.ref = ref
        self.detector = detector
        self.metadata = metadata
        self.manifests = manifests
        self.scanned = scanned
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.version = try values.decode(Int.self, forKey: "version")
        self.job = try values.decode(Job.self, forKey: "job")
        self.sha = try values.decode(String.self, forKey: "sha")
        self.ref = try values.decode(String.self, forKey: "ref")
        self.detector = try values.decode(Detector.self, forKey: "detector")
        self.metadata = try values.decodeIfPresent([String: Metadatum].self, forKey: "metadata")
        self.manifests = try values.decodeIfPresent([String: Manifest].self, forKey: "manifests")
        self.scanned = try values.decode(Date.self, forKey: "scanned")
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(version, forKey: "version")
        try values.encode(job, forKey: "job")
        try values.encode(sha, forKey: "sha")
        try values.encode(ref, forKey: "ref")
        try values.encode(detector, forKey: "detector")
        try values.encodeIfPresent(metadata, forKey: "metadata")
        try values.encodeIfPresent(manifests, forKey: "manifests")
        try values.encode(scanned, forKey: "scanned")
    }
}
