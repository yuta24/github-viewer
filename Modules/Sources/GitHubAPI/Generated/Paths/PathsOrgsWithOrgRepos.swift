// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Orgs.WithOrg {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/orgs/{org}/repos`
        public let path: String

        /// List organization repositories
        ///
        /// Lists repositories for the specified organization.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#list-organization-repositories)
        public func get(parameters: GetParameters? = nil) -> Request<[GitHubAPI.MinimalRepository]> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "repos/list-for-org")
        }

        public enum GetResponseHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetParameters {
            public var type: `Type`?
            public var sort: Sort?
            public var direction: Direction?
            public var perPage: Int?
            public var page: Int?

            public enum `Type`: String, Codable, CaseIterable {
                case all
                case `public`
                case `private`
                case forks
                case sources
                case member
                case `internal`
            }

            public enum Sort: String, Codable, CaseIterable {
                case created
                case updated
                case pushed
                case fullName = "full_name"
            }

            public enum Direction: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public init(type: `Type`? = nil, sort: Sort? = nil, direction: Direction? = nil, perPage: Int? = nil, page: Int? = nil) {
                self.type = type
                self.sort = sort
                self.direction = direction
                self.perPage = perPage
                self.page = page
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(perPage, forKey: "per_page")
                encoder.encode(page, forKey: "page")
                return encoder.items
            }
        }

        /// Create an organization repository
        ///
        /// Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
        /// 
        /// **OAuth scope requirements**
        /// 
        /// When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
        /// 
        /// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        /// *   `repo` scope to create a private repository
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#create-an-organization-repository)
        public func post(_ body: PostRequest) -> Request<GitHubAPI.Repository> {
            Request(method: "POST", url: path, body: body, id: "repos/create-in-org")
        }

        public enum PostResponseHeaders {
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostRequest: Encodable {
            /// The name of the repository.
            public var name: String
            /// A short description of the repository.
            public var description: String?
            /// A URL with more information about the repository.
            public var homepage: String?
            /// Whether the repository is private.
            public var isPrivate: Bool
            /// Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.
            public var visibility: Visibility?
            /// Either `true` to enable issues for this repository or `false` to disable them.
            public var hasIssues: Bool
            /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
            public var hasProjects: Bool
            /// Either `true` to enable the wiki for this repository or `false` to disable it.
            public var hasWiki: Bool
            /// Either `true` to make this repo available as a template repository or `false` to prevent it.
            public var isTemplate: Bool
            /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
            public var teamID: Int?
            /// Pass `true` to create an initial commit with empty README.
            public var isAutoInit: Bool
            /// Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
            public var gitignoreTemplate: String?
            /// Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
            public var licenseTemplate: String?
            /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
            public var allowSquashMerge: Bool
            /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
            public var allowMergeCommit: Bool
            /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
            public var allowRebaseMerge: Bool
            /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
            public var allowAutoMerge: Bool
            /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
            public var deleteBranchOnMerge: Bool
            /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.
            ///
            /// - warning: Deprecated.
            public var useSquashPrTitleAsDefault: Bool
            /// The default value for a squash merge commit title:
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            public var squashMergeCommitTitle: SquashMergeCommitTitle?
            /// The default value for a squash merge commit message:
            /// 
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            public var squashMergeCommitMessage: SquashMergeCommitMessage?
            /// The default value for a merge commit title.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            public var mergeCommitTitle: MergeCommitTitle?
            /// The default value for a merge commit message.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            public var mergeCommitMessage: MergeCommitMessage?

            /// Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.
            public enum Visibility: String, Codable, CaseIterable {
                case `public`
                case `private`
                case `internal`
            }

            /// The default value for a squash merge commit title:
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            public enum SquashMergeCommitTitle: String, Codable, CaseIterable {
                case prTitle = "PR_TITLE"
                case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
            }

            /// The default value for a squash merge commit message:
            /// 
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            public enum SquashMergeCommitMessage: String, Codable, CaseIterable {
                case prBody = "PR_BODY"
                case commitMessages = "COMMIT_MESSAGES"
                case blank = "BLANK"
            }

            /// The default value for a merge commit title.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            public enum MergeCommitTitle: String, Codable, CaseIterable {
                case prTitle = "PR_TITLE"
                case mergeMessage = "MERGE_MESSAGE"
            }

            /// The default value for a merge commit message.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            public enum MergeCommitMessage: String, Codable, CaseIterable {
                case prBody = "PR_BODY"
                case prTitle = "PR_TITLE"
                case blank = "BLANK"
            }

            public init(name: String, description: String? = nil, homepage: String? = nil, isPrivate: Bool? = nil, visibility: Visibility? = nil, hasIssues: Bool? = nil, hasProjects: Bool? = nil, hasWiki: Bool? = nil, isTemplate: Bool? = nil, teamID: Int? = nil, isAutoInit: Bool? = nil, gitignoreTemplate: String? = nil, licenseTemplate: String? = nil, allowSquashMerge: Bool? = nil, allowMergeCommit: Bool? = nil, allowRebaseMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, useSquashPrTitleAsDefault: Bool? = nil, squashMergeCommitTitle: SquashMergeCommitTitle? = nil, squashMergeCommitMessage: SquashMergeCommitMessage? = nil, mergeCommitTitle: MergeCommitTitle? = nil, mergeCommitMessage: MergeCommitMessage? = nil) {
                self.name = name
                self.description = description
                self.homepage = homepage
                self.isPrivate = isPrivate ?? false
                self.visibility = visibility
                self.hasIssues = hasIssues ?? true
                self.hasProjects = hasProjects ?? true
                self.hasWiki = hasWiki ?? true
                self.isTemplate = isTemplate ?? false
                self.teamID = teamID
                self.isAutoInit = isAutoInit ?? false
                self.gitignoreTemplate = gitignoreTemplate
                self.licenseTemplate = licenseTemplate
                self.allowSquashMerge = allowSquashMerge ?? true
                self.allowMergeCommit = allowMergeCommit ?? true
                self.allowRebaseMerge = allowRebaseMerge ?? true
                self.allowAutoMerge = allowAutoMerge ?? false
                self.deleteBranchOnMerge = deleteBranchOnMerge ?? false
                self.useSquashPrTitleAsDefault = useSquashPrTitleAsDefault ?? false
                self.squashMergeCommitTitle = squashMergeCommitTitle
                self.squashMergeCommitMessage = squashMergeCommitMessage
                self.mergeCommitTitle = mergeCommitTitle
                self.mergeCommitMessage = mergeCommitMessage
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(name, forKey: "name")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encodeIfPresent(homepage, forKey: "homepage")
                try values.encodeIfPresent(isPrivate, forKey: "private")
                try values.encodeIfPresent(visibility, forKey: "visibility")
                try values.encodeIfPresent(hasIssues, forKey: "has_issues")
                try values.encodeIfPresent(hasProjects, forKey: "has_projects")
                try values.encodeIfPresent(hasWiki, forKey: "has_wiki")
                try values.encodeIfPresent(isTemplate, forKey: "is_template")
                try values.encodeIfPresent(teamID, forKey: "team_id")
                try values.encodeIfPresent(isAutoInit, forKey: "auto_init")
                try values.encodeIfPresent(gitignoreTemplate, forKey: "gitignore_template")
                try values.encodeIfPresent(licenseTemplate, forKey: "license_template")
                try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
                try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
                try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
                try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
                try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
                try values.encodeIfPresent(useSquashPrTitleAsDefault, forKey: "use_squash_pr_title_as_default")
                try values.encodeIfPresent(squashMergeCommitTitle, forKey: "squash_merge_commit_title")
                try values.encodeIfPresent(squashMergeCommitMessage, forKey: "squash_merge_commit_message")
                try values.encodeIfPresent(mergeCommitTitle, forKey: "merge_commit_title")
                try values.encodeIfPresent(mergeCommitMessage, forKey: "merge_commit_message")
            }
        }
    }
}
