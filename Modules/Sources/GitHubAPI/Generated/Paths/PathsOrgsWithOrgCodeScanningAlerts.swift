// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Orgs.WithOrg.CodeScanning {
    public var alerts: Alerts {
        Alerts(path: path + "/alerts")
    }

    public struct Alerts {
        /// Path: `/orgs/{org}/code-scanning/alerts`
        public let path: String

        /// List code scanning alerts for an organization
        ///
        /// Lists code scanning alerts for the default branch for all eligible repositories in an organization. Eligible repositories are repositories that are owned by organizations that you own or for which you are a security manager. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
        /// 
        /// To use this endpoint, you must be an owner or security manager for the organization, and you must use an access token with the `repo` scope or `security_events` scope.
        /// 
        /// For public repositories, you may instead use the `public_repo` scope.
        /// 
        /// GitHub Apps must have the `security_events` read permission to use this endpoint.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/code-scanning#list-code-scanning-alerts-by-organization)
        public func get(parameters: GetParameters? = nil) -> Request<[GitHubAPI.CodeScanningOrganizationAlertItems]> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "code-scanning/list-alerts-for-org")
        }

        public enum GetResponseHeaders {
            public static let link = HTTPHeader<String>(field: "Link")
        }

        public struct GetParameters {
            /// The name of the tool used to generate the code scanning analysis.
            public var toolName: String?
            /// The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.
            public var toolGuid: String?
            public var before: String?
            public var after: String?
            public var page: Int?
            public var perPage: Int?
            public var direction: Direction?
            /// State of a code scanning alert.
            public var state: State?
            public var sort: Sort?

            public enum Direction: String, Codable, CaseIterable {
                case asc
                case desc
            }

            /// State of a code scanning alert.
            public enum State: String, Codable, CaseIterable {
                case `open`
                case closed
                case dismissed
                case fixed
            }

            public enum Sort: String, Codable, CaseIterable {
                case created
                case updated
            }

            public init(toolName: String? = nil, toolGuid: String? = nil, before: String? = nil, after: String? = nil, page: Int? = nil, perPage: Int? = nil, direction: Direction? = nil, state: State? = nil, sort: Sort? = nil) {
                self.toolName = toolName
                self.toolGuid = toolGuid
                self.before = before
                self.after = after
                self.page = page
                self.perPage = perPage
                self.direction = direction
                self.state = state
                self.sort = sort
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(toolName, forKey: "tool_name")
                encoder.encode(toolGuid, forKey: "tool_guid")
                encoder.encode(before, forKey: "before")
                encoder.encode(after, forKey: "after")
                encoder.encode(page, forKey: "page")
                encoder.encode(perPage, forKey: "per_page")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(state, forKey: "state")
                encoder.encode(sort, forKey: "sort")
                return encoder.items
            }
        }
    }
}
