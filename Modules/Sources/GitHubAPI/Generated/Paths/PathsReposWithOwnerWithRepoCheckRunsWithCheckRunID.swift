// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Repos.WithOwner.WithRepo.CheckRuns {
    public func checkRunID(_ checkRunID: Int) -> WithCheckRunID {
        WithCheckRunID(path: "\(path)/\(checkRunID)")
    }

    public struct WithCheckRunID {
        /// Path: `/repos/{owner}/{repo}/check-runs/{check_run_id}`
        public let path: String

        /// Get a check run
        ///
        /// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
        /// 
        /// Gets a single check run using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check runs. OAuth Apps and authenticated users must have the `repo` scope to get check runs in a private repository.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/checks#get-a-check-run)
        public var get: Request<GitHubAPI.CheckRun> {
            Request(method: "GET", url: path, id: "checks/get")
        }

        /// Update a check run
        ///
        /// **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array.
        /// 
        /// Updates a check run for a specific commit in a repository. Your GitHub App must have the `checks:write` permission to edit check runs.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/checks#update-a-check-run)
        public func patch(_ body: PatchRequest) -> Request<GitHubAPI.CheckRun> {
            Request(method: "PATCH", url: path, body: body, id: "checks/update")
        }

        public struct PatchRequest: Encodable {
            public var a: A?
            public var b: B?

            public struct A: Encodable {
                public var status: AnyJSON?
                public var conclusion: AnyJSON

                public init(status: AnyJSON? = nil, conclusion: AnyJSON) {
                    self.status = status
                    self.conclusion = conclusion
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(status, forKey: "status")
                    try values.encode(conclusion, forKey: "conclusion")
                }
            }

            public struct B: Encodable {
                public var status: AnyJSON?

                public init(status: AnyJSON? = nil) {
                    self.status = status
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(status, forKey: "status")
                }
            }

            public init(a: A? = nil, b: B? = nil) {
                self.a = a
                self.b = b
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = a { try container.encode(value) }
                if let value = b { try container.encode(value) }
            }
        }
    }
}
