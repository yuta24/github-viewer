// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Repos.WithOwner.WithRepo.DependencyGraph {
    public var snapshots: Snapshots {
        Snapshots(path: path + "/snapshots")
    }

    public struct Snapshots {
        /// Path: `/repos/{owner}/{repo}/dependency-graph/snapshots`
        public let path: String

        /// Create a snapshot of dependencies for a repository
        ///
        /// Create a new snapshot of a repository's dependencies. You must authenticate using an access token with the `repo` scope to use this endpoint for a repository that the requesting user has access to.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/dependency-graph#create-a-snapshot-of-dependencies-for-a-repository)
        public func post(_ body: GitHubAPI.Snapshot) -> Request<PostResponse> {
            Request(method: "POST", url: path, body: body, id: "dependency-graph/create-repository-snapshot")
        }

        public struct PostResponse: Decodable, Identifiable {
            /// ID of the created snapshot.
            public var id: Int
            /// The time at which the snapshot was created.
            public var createdAt: String
            /// Either "SUCCESS", "ACCEPTED", or "INVALID". "SUCCESS" indicates that the snapshot was successfully created and the repository's dependencies were updated. "ACCEPTED" indicates that the snapshot was successfully created, but the repository's dependencies were not updated. "INVALID" indicates that the snapshot was malformed.
            public var result: String
            /// A message providing further details about the result, such as why the dependencies were not updated.
            public var message: String

            public init(id: Int, createdAt: String, result: String, message: String) {
                self.id = id
                self.createdAt = createdAt
                self.result = result
                self.message = message
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.id = try values.decode(Int.self, forKey: "id")
                self.createdAt = try values.decode(String.self, forKey: "created_at")
                self.result = try values.decode(String.self, forKey: "result")
                self.message = try values.decode(String.self, forKey: "message")
            }
        }
    }
}
