// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.User {
    public var repos: Repos {
        Repos(path: path + "/repos")
    }

    public struct Repos {
        /// Path: `/user/repos`
        public let path: String

        /// List repositories for the authenticated user
        ///
        /// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
        /// 
        /// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#list-repositories-for-the-authenticated-user)
        public func get(parameters: GetParameters? = nil) -> Request<[GitHubAPI.Repository]> {
            Request(method: "GET", url: path, query: parameters?.asQuery, id: "repos/list-for-authenticated-user")
        }

        public struct GetParameters {
            public var visibility: Visibility?
            public var affiliation: String?
            public var type: `Type`?
            public var sort: Sort?
            public var direction: Direction?
            public var perPage: Int?
            public var page: Int?
            public var since: Date?
            public var before: Date?

            public enum Visibility: String, Codable, CaseIterable {
                case all
                case `public`
                case `private`
            }

            public enum `Type`: String, Codable, CaseIterable {
                case all
                case owner
                case `public`
                case `private`
                case member
            }

            public enum Sort: String, Codable, CaseIterable {
                case created
                case updated
                case pushed
                case fullName = "full_name"
            }

            public enum Direction: String, Codable, CaseIterable {
                case asc
                case desc
            }

            public init(visibility: Visibility? = nil, affiliation: String? = nil, type: `Type`? = nil, sort: Sort? = nil, direction: Direction? = nil, perPage: Int? = nil, page: Int? = nil, since: Date? = nil, before: Date? = nil) {
                self.visibility = visibility
                self.affiliation = affiliation
                self.type = type
                self.sort = sort
                self.direction = direction
                self.perPage = perPage
                self.page = page
                self.since = since
                self.before = before
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(visibility, forKey: "visibility")
                encoder.encode(affiliation, forKey: "affiliation")
                encoder.encode(type, forKey: "type")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(direction, forKey: "direction")
                encoder.encode(perPage, forKey: "per_page")
                encoder.encode(page, forKey: "page")
                encoder.encode(since, forKey: "since")
                encoder.encode(before, forKey: "before")
                return encoder.items
            }
        }

        /// Create a repository for the authenticated user
        ///
        /// Creates a new repository for the authenticated user.
        /// 
        /// **OAuth scope requirements**
        /// 
        /// When using [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
        /// 
        /// *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
        /// *   `repo` scope to create a private repository.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#create-a-repository-for-the-authenticated-user)
        public func post(_ body: PostRequest) -> Request<GitHubAPI.Repository> {
            Request(method: "POST", url: path, body: body, id: "repos/create-for-authenticated-user")
        }

        public enum PostResponseHeaders {
            public static let location = HTTPHeader<String>(field: "Location")
        }

        public struct PostRequest: Encodable {
            /// The name of the repository.
            ///
            /// Example: "Team Environment"
            public var name: String
            /// A short description of the repository.
            public var description: String?
            /// A URL with more information about the repository.
            public var homepage: String?
            /// Whether the repository is private.
            public var isPrivate: Bool
            /// Whether issues are enabled.
            ///
            /// Example: true
            public var hasIssues: Bool
            /// Whether projects are enabled.
            ///
            /// Example: true
            public var hasProjects: Bool
            /// Whether the wiki is enabled.
            ///
            /// Example: true
            public var hasWiki: Bool
            /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
            public var teamID: Int?
            /// Whether the repository is initialized with a minimal README.
            public var isAutoInit: Bool
            /// The desired language or platform to apply to the .gitignore.
            ///
            /// Example: "Haskell"
            public var gitignoreTemplate: String?
            /// The license keyword of the open source license for this repository.
            ///
            /// Example: "mit"
            public var licenseTemplate: String?
            /// Whether to allow squash merges for pull requests.
            ///
            /// Example: true
            public var allowSquashMerge: Bool
            /// Whether to allow merge commits for pull requests.
            ///
            /// Example: true
            public var allowMergeCommit: Bool
            /// Whether to allow rebase merges for pull requests.
            ///
            /// Example: true
            public var allowRebaseMerge: Bool
            /// Whether to allow Auto-merge to be used on pull requests.
            ///
            /// Example: false
            public var allowAutoMerge: Bool
            /// Whether to delete head branches when pull requests are merged
            ///
            /// Example: false
            public var deleteBranchOnMerge: Bool
            /// The default value for a squash merge commit title:
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            public var squashMergeCommitTitle: SquashMergeCommitTitle?
            /// The default value for a squash merge commit message:
            /// 
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            public var squashMergeCommitMessage: SquashMergeCommitMessage?
            /// The default value for a merge commit title.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            public var mergeCommitTitle: MergeCommitTitle?
            /// The default value for a merge commit message.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            public var mergeCommitMessage: MergeCommitMessage?
            /// Whether downloads are enabled.
            ///
            /// Example: true
            public var hasDownloads: Bool
            /// Whether this repository acts as a template that can be used to generate new repositories.
            ///
            /// Example: true
            public var isTemplate: Bool

            /// The default value for a squash merge commit title:
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            public enum SquashMergeCommitTitle: String, Codable, CaseIterable {
                case prTitle = "PR_TITLE"
                case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
            }

            /// The default value for a squash merge commit message:
            /// 
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            public enum SquashMergeCommitMessage: String, Codable, CaseIterable {
                case prBody = "PR_BODY"
                case commitMessages = "COMMIT_MESSAGES"
                case blank = "BLANK"
            }

            /// The default value for a merge commit title.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            public enum MergeCommitTitle: String, Codable, CaseIterable {
                case prTitle = "PR_TITLE"
                case mergeMessage = "MERGE_MESSAGE"
            }

            /// The default value for a merge commit message.
            /// 
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            public enum MergeCommitMessage: String, Codable, CaseIterable {
                case prBody = "PR_BODY"
                case prTitle = "PR_TITLE"
                case blank = "BLANK"
            }

            public init(name: String, description: String? = nil, homepage: String? = nil, isPrivate: Bool? = nil, hasIssues: Bool? = nil, hasProjects: Bool? = nil, hasWiki: Bool? = nil, teamID: Int? = nil, isAutoInit: Bool? = nil, gitignoreTemplate: String? = nil, licenseTemplate: String? = nil, allowSquashMerge: Bool? = nil, allowMergeCommit: Bool? = nil, allowRebaseMerge: Bool? = nil, allowAutoMerge: Bool? = nil, deleteBranchOnMerge: Bool? = nil, squashMergeCommitTitle: SquashMergeCommitTitle? = nil, squashMergeCommitMessage: SquashMergeCommitMessage? = nil, mergeCommitTitle: MergeCommitTitle? = nil, mergeCommitMessage: MergeCommitMessage? = nil, hasDownloads: Bool? = nil, isTemplate: Bool? = nil) {
                self.name = name
                self.description = description
                self.homepage = homepage
                self.isPrivate = isPrivate ?? false
                self.hasIssues = hasIssues ?? true
                self.hasProjects = hasProjects ?? true
                self.hasWiki = hasWiki ?? true
                self.teamID = teamID
                self.isAutoInit = isAutoInit ?? false
                self.gitignoreTemplate = gitignoreTemplate
                self.licenseTemplate = licenseTemplate
                self.allowSquashMerge = allowSquashMerge ?? true
                self.allowMergeCommit = allowMergeCommit ?? true
                self.allowRebaseMerge = allowRebaseMerge ?? true
                self.allowAutoMerge = allowAutoMerge ?? false
                self.deleteBranchOnMerge = deleteBranchOnMerge ?? false
                self.squashMergeCommitTitle = squashMergeCommitTitle
                self.squashMergeCommitMessage = squashMergeCommitMessage
                self.mergeCommitTitle = mergeCommitTitle
                self.mergeCommitMessage = mergeCommitMessage
                self.hasDownloads = hasDownloads ?? true
                self.isTemplate = isTemplate ?? false
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(name, forKey: "name")
                try values.encodeIfPresent(description, forKey: "description")
                try values.encodeIfPresent(homepage, forKey: "homepage")
                try values.encodeIfPresent(isPrivate, forKey: "private")
                try values.encodeIfPresent(hasIssues, forKey: "has_issues")
                try values.encodeIfPresent(hasProjects, forKey: "has_projects")
                try values.encodeIfPresent(hasWiki, forKey: "has_wiki")
                try values.encodeIfPresent(teamID, forKey: "team_id")
                try values.encodeIfPresent(isAutoInit, forKey: "auto_init")
                try values.encodeIfPresent(gitignoreTemplate, forKey: "gitignore_template")
                try values.encodeIfPresent(licenseTemplate, forKey: "license_template")
                try values.encodeIfPresent(allowSquashMerge, forKey: "allow_squash_merge")
                try values.encodeIfPresent(allowMergeCommit, forKey: "allow_merge_commit")
                try values.encodeIfPresent(allowRebaseMerge, forKey: "allow_rebase_merge")
                try values.encodeIfPresent(allowAutoMerge, forKey: "allow_auto_merge")
                try values.encodeIfPresent(deleteBranchOnMerge, forKey: "delete_branch_on_merge")
                try values.encodeIfPresent(squashMergeCommitTitle, forKey: "squash_merge_commit_title")
                try values.encodeIfPresent(squashMergeCommitMessage, forKey: "squash_merge_commit_message")
                try values.encodeIfPresent(mergeCommitTitle, forKey: "merge_commit_title")
                try values.encodeIfPresent(mergeCommitMessage, forKey: "merge_commit_message")
                try values.encodeIfPresent(hasDownloads, forKey: "has_downloads")
                try values.encodeIfPresent(isTemplate, forKey: "is_template")
            }
        }
    }
}
