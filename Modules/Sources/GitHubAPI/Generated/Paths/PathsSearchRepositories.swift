// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Search {
    public var repositories: Repositories {
        Repositories(path: path + "/repositories")
    }

    public struct Repositories {
        /// Path: `/search/repositories`
        public let path: String

        /// Search repositories
        ///
        /// Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/rest/overview/resources-in-the-rest-api#pagination).
        /// 
        /// When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/rest/reference/search#text-match-metadata).
        /// 
        /// For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
        /// 
        /// `q=tetris+language:assembly&sort=stars&order=desc`
        /// 
        /// This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/search#search-repositories)
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: parameters.asQuery, id: "search/repos")
        }

        public struct GetResponse: Decodable {
            public var totalCount: Int
            public var isIncompleteResults: Bool
            public var items: [GitHubAPI.RepoSearchResultItem]

            public init(totalCount: Int, isIncompleteResults: Bool, items: [GitHubAPI.RepoSearchResultItem]) {
                self.totalCount = totalCount
                self.isIncompleteResults = isIncompleteResults
                self.items = items
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: StringCodingKey.self)
                self.totalCount = try values.decode(Int.self, forKey: "total_count")
                self.isIncompleteResults = try values.decode(Bool.self, forKey: "incomplete_results")
                self.items = try values.decode([GitHubAPI.RepoSearchResultItem].self, forKey: "items")
            }
        }

        public struct GetParameters {
            public var q: String
            public var sort: Sort?
            public var order: Order?
            public var perPage: Int?
            public var page: Int?

            public enum Sort: String, Codable, CaseIterable {
                case stars
                case forks
                case helpWantedIssues = "help-wanted-issues"
                case updated
            }

            public enum Order: String, Codable, CaseIterable {
                case desc
                case asc
            }

            public init(q: String, sort: Sort? = nil, order: Order? = nil, perPage: Int? = nil, page: Int? = nil) {
                self.q = q
                self.sort = sort
                self.order = order
                self.perPage = perPage
                self.page = page
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(q, forKey: "q")
                encoder.encode(sort, forKey: "sort")
                encoder.encode(order, forKey: "order")
                encoder.encode(perPage, forKey: "per_page")
                encoder.encode(page, forKey: "page")
                return encoder.items
            }
        }
    }
}
