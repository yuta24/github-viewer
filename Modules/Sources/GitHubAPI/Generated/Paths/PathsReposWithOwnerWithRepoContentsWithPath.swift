// Generated by Create API
// https://github.com/CreateAPI/CreateAPI

import Foundation
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths.Repos.WithOwner.WithRepo.Contents {
    public func path(_ path: String) -> WithPath {
        WithPath(path: "\(path)/\(path)")
    }

    public struct WithPath {
        /// Path: `/repos/{owner}/{repo}/contents/{path}`
        public let path: String

        /// Get repository content
        ///
        /// Gets the contents of a file or directory in a repository. Specify the file path or directory in `:path`. If you omit
        /// `:path`, you will receive the contents of the repository's root directory. See the description below regarding what the API response includes for directories. 
        /// 
        /// Files and symlinks support [a custom media type](https://docs.github.com/rest/reference/repos#custom-media-types) for
        /// retrieving the raw content or rendered HTML (when supported). All content types support [a custom media
        /// type](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content is returned in a consistent
        /// object format.
        /// 
        /// **Notes**:
        /// *   To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/reference/git#trees).
        /// *   This API has an upper limit of 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
        /// API](https://docs.github.com/rest/reference/git#get-a-tree).
        ///  *  Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
        /// #### Size limits
        /// If the requested file's size is:
        /// * 1 MB or smaller: All features of this endpoint are supported.
        /// * Between 1-100 MB: Only the `raw` or `object` [custom media types](https://docs.github.com/rest/repos/contents#custom-media-types-for-repository-contents) are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
        ///  * Greater than 100 MB: This endpoint is not supported.
        /// 
        /// #### If the content is a directory
        /// The response will be an array of objects, one object for each item in the directory.
        /// When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value
        /// _should_ be "submodule". This behavior exists in API v3 [for backwards compatibility purposes](https://git.io/v1YCW).
        /// In the next major version of the API, the type will be returned as "submodule".
        /// 
        /// #### If the content is a symlink 
        /// If the requested `:path` points to a symlink, and the symlink's target is a normal file in the repository, then the
        /// API responds with the content of the file (in the format shown in the example. Otherwise, the API responds with an object 
        /// describing the symlink itself.
        /// 
        /// #### If the content is a submodule
        /// The `submodule_git_url` identifies the location of the submodule repository, and the `sha` identifies a specific
        /// commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out
        /// the submodule at that specific commit.
        /// 
        /// If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the
        /// github.com URLs (`html_url` and `_links["html"]`) will have null values.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#get-repository-content)
        public func get(ref: String? = nil) -> Request<GetResponse> {
            Request(method: "GET", url: path, query: makeGetQuery(ref), id: "repos/get-content")
        }

        public enum GetResponse: Decodable {
            case contentDirectoryItems([ContentDirectoryItem])
            case contentFile(GitHubAPI.ContentFile)
            case contentSymlink(GitHubAPI.ContentSymlink)
            case contentSubmodule(GitHubAPI.ContentSubmodule)

            public init(from decoder: Decoder) throws {
                let container = try decoder.singleValueContainer()
                if let value = try? container.decode([ContentDirectoryItem].self) {
                    self = .contentDirectoryItems(value)
                } else if let value = try? container.decode(GitHubAPI.ContentFile.self) {
                    self = .contentFile(value)
                } else if let value = try? container.decode(GitHubAPI.ContentSymlink.self) {
                    self = .contentSymlink(value)
                } else if let value = try? container.decode(GitHubAPI.ContentSubmodule.self) {
                    self = .contentSubmodule(value)
                } else {
                    throw DecodingError.dataCorruptedError(
                        in: container,
                        debugDescription: "Data could not be decoded as any of the expected types ([ContentDirectoryItem], GitHubAPI.ContentFile, GitHubAPI.ContentSymlink, GitHubAPI.ContentSubmodule)."
                    )
                }
            }
        }

        private func makeGetQuery(_ ref: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(ref, forKey: "ref")
            return encoder.items
        }

        /// Create or update file contents
        ///
        /// Creates a new file or replaces an existing file in a repository. You must authenticate using an access token with the `workflow` scope to use this endpoint.
        /// 
        /// **Note:** If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/reference/repos/#delete-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#create-or-update-file-contents)
        public func put(_ body: PutRequest) -> Request<GitHubAPI.FileCommit> {
            Request(method: "PUT", url: path, body: body, id: "repos/create-or-update-file-contents")
        }

        public struct PutRequest: Encodable {
            /// The commit message.
            public var message: String
            /// The new file content, using Base64 encoding.
            public var content: String
            /// **Required if you are updating a file**. The blob SHA of the file being replaced.
            public var sha: String?
            /// The branch name. Default: the repository’s default branch (usually `master`)
            public var branch: String?
            /// The person that committed the file. Default: the authenticated user.
            public var committer: Committer?
            /// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
            public var author: Author?

            /// The person that committed the file. Default: the authenticated user.
            public struct Committer: Encodable {
                /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                public var name: String
                /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                public var email: String
                /// Example: "2013-01-05T13:13:22+05:00"
                public var date: String?

                public init(name: String, email: String, date: String? = nil) {
                    self.name = name
                    self.email = email
                    self.date = date
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(name, forKey: "name")
                    try values.encode(email, forKey: "email")
                    try values.encodeIfPresent(date, forKey: "date")
                }
            }

            /// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
            public struct Author: Encodable {
                /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                public var name: String
                /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                public var email: String
                /// Example: "2013-01-15T17:13:22+05:00"
                public var date: String?

                public init(name: String, email: String, date: String? = nil) {
                    self.name = name
                    self.email = email
                    self.date = date
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encode(name, forKey: "name")
                    try values.encode(email, forKey: "email")
                    try values.encodeIfPresent(date, forKey: "date")
                }
            }

            public init(message: String, content: String, sha: String? = nil, branch: String? = nil, committer: Committer? = nil, author: Author? = nil) {
                self.message = message
                self.content = content
                self.sha = sha
                self.branch = branch
                self.committer = committer
                self.author = author
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(message, forKey: "message")
                try values.encode(content, forKey: "content")
                try values.encodeIfPresent(sha, forKey: "sha")
                try values.encodeIfPresent(branch, forKey: "branch")
                try values.encodeIfPresent(committer, forKey: "committer")
                try values.encodeIfPresent(author, forKey: "author")
            }
        }

        /// Delete a file
        ///
        /// Deletes a file in a repository.
        /// 
        /// You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
        /// 
        /// The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
        /// 
        /// You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
        /// 
        /// **Note:** If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/reference/repos/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
        ///
        /// [API method documentation](https://docs.github.com/rest/reference/repos#delete-a-file)
        public func delete(_ body: DeleteRequest) -> Request<GitHubAPI.FileCommit> {
            Request(method: "DELETE", url: path, body: body, id: "repos/delete-file")
        }

        public struct DeleteRequest: Encodable {
            /// The commit message.
            public var message: String
            /// The blob SHA of the file being deleted.
            public var sha: String
            /// The branch name. Default: the repository’s default branch (usually `master`)
            public var branch: String?
            /// Object containing information about the committer.
            public var committer: Committer?
            /// Object containing information about the author.
            public var author: Author?

            /// Object containing information about the committer.
            public struct Committer: Encodable {
                /// The name of the author (or committer) of the commit
                public var name: String?
                /// The email of the author (or committer) of the commit
                public var email: String?

                public init(name: String? = nil, email: String? = nil) {
                    self.name = name
                    self.email = email
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(name, forKey: "name")
                    try values.encodeIfPresent(email, forKey: "email")
                }
            }

            /// Object containing information about the author.
            public struct Author: Encodable {
                /// The name of the author (or committer) of the commit
                public var name: String?
                /// The email of the author (or committer) of the commit
                public var email: String?

                public init(name: String? = nil, email: String? = nil) {
                    self.name = name
                    self.email = email
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(name, forKey: "name")
                    try values.encodeIfPresent(email, forKey: "email")
                }
            }

            public init(message: String, sha: String, branch: String? = nil, committer: Committer? = nil, author: Author? = nil) {
                self.message = message
                self.sha = sha
                self.branch = branch
                self.committer = committer
                self.author = author
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(message, forKey: "message")
                try values.encode(sha, forKey: "sha")
                try values.encodeIfPresent(branch, forKey: "branch")
                try values.encodeIfPresent(committer, forKey: "committer")
                try values.encodeIfPresent(author, forKey: "author")
            }
        }
    }
}
